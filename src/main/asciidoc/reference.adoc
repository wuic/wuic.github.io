:toc: right

++++
    <!-- styles -->
    <link href="bootstrap/css/bootstrap.css" rel="stylesheet" />
    <link href="wiki-css/theme.css" rel="stylesheet" />
    <link href="bootstrap/css/bootstrap-responsive.css" rel="stylesheet" />
    <link href="font-awesome/css/font-awesome.css" rel="stylesheet" />

    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
    <script src="../assets/js/html5shiv.js"></script>
    <![endif]-->

    <!-- Favicon -->
    <link rel="shortcut icon" href="wiki-images/logo/favicon.ico" type="image/x-icon">
    <link rel="icon" href="wiki-images/logo/favicon.ico" type="image/x-icon">

    <div class="masthead">
        <div class="navbar">
            <div class="navbar-inner">
                <div class="container">
                    <ul class="nav" role="navigation">
                        <!-- Logo and slogan -->
                        <li><a href="index.html"><i class="icon-home"></i><span class="hidden-phone">&nbsp;Home</span></a></li>
                        <li><a href="project.html"><i class="icon-star"></i><span class="hidden-phone">&nbsp;Project</span></a></li>
                        <li class="active"><a href="wuic-documentation.html"><i class="icon-book"></i><span class="hidden-phone">&nbsp;Documentation</span></a></li>
                        <li><a href="contact.html"><i class="icon-envelope"></i><span class="hidden-phone">&nbsp;Contact</span></a></li>
                        <li><a href="https://github.com/wuic/wuic" target="_blank" title="Wuic Github"><i class="icon-github"></i><span class="hidden-phone">&nbsp;Github</span></a></li>
                        <li><a href="https://twitter.com/wuic_project" target="_blank"><i class="icon-twitter"></i><span class="hidden-phone">&nbsp;Twitter</span></a></li>
                    </ul>
                </div>
            </div>
        </div><!-- /.navbar -->
    </div>
++++

== Supported server and known issues

WUIC is designed to be deployed in any `Servlet 3` compatible server running on top of `Java 6` and above:

* `Jetty` since `8.0`
* `Tomcat` since `7.0`
* `GlassFish` since `3.0`
* `JBoss` since `6.0`
* `WebLogic` since `12.0`
* `Undertow` since `1.0`

However, some features have a limited support on some specific version.
Known issues are identified with a link to the details and workaround in the table below.

++++
<table>
  <tr>
    <td><b>Feature/Servlet Container</b></td>
    <td>Jetty</td>
    <td>Tomcat</td>
    <td>GlassFish</td>
    <td>JBoss</td>
    <td>WebLogic</td>
    <td>Undertow (Wildfly)</td>
  </tr>
  <tr>
    <td><a href="#_unknown_mime_type_in_filter">Unknown MIME type in Filter</a></td>
    <td>OK</td>
    <td>OK</td>
    <td>Test needed!</td>
    <td>Test needed!</td>
    <td>Test needed!</td>
    <td>Before 1.1 (Wildfly 8.1)</td>
  </tr>
  <tr>
    <td><a href="#_best_effort_warmup_polling_and_async_version_computation">Best effort, warmup, polling and async version computation</a></td>
    <td>Since 9.3.0.M2</td>
    <td>OK</td>
    <td>Test needed!</td>
    <td>Test needed!</td>
    <td>Test needed!</td>
    <td>Before 1.2</td>
  </tr>
</table>
++++

=== Unknown MIME type in Filter

Because of https://issues.jboss.org/browse/UNDERTOW-268[UNDERTOW-268] issue, WUIC's servlet filter will fails if you deploy it on Undertow 1.0 (which is the default HTTP server in Wildfly 8.0 and 8.1).

A workaround exist: create a filter that force the mime type on resources filtered by WUIC. For instance:

[source,java]
----
include::{sample-repository}bootstrap3-sample/src/main/java/com/github/wuic/sample/MimeTypeFilter.java[tags=MimeTypeFilter]
----

=== Best effort, warmup, polling and async version computation

When a `Nut` is created with the `RequestDispatcherNutDao` component, the path is resolve with the `ServletContext#getResource(String)`
method, which works fine in any servlet container.

However, the content is dynamic (generated by a `Servlet` or a `JSP`), you must tell WUIC to use `RequestDispatcher#include(HttpServletRequest,HttpServletResponse)`
thanks to the `c.g.wuic.dao.useIncludeForPathPattern` that accepts a regex matching the desired path.
The problem is that following references explain that any attempt to use a `RequestDispatcher` outside the HTTP request/response lifecycle and/or in another thread will fail:

* https://issues.jboss.org/browse/UNDERTOW-357[UNDERTOW-357 fixed in 1.2]
* https://github.com/eclipse/jetty.project/commit/c23f21c761ff56f2ad4841a98083b237494442de#commitcomment-10495706[Optimization in Jetty 9.3 that won't be removed]

This lead to the following limitations when you use the `RequestDispatcherNutDao`, which is the default DAO in the `HtmlParserFilter`:

* Warmup strategy must be set to NONE (default setting)
* Version number must be computed synchronously (done asynchronously by default)
* Nut polling must be disabled (default setting)
* Cache engines must disable best effort (default setting)

Considering those points, you should be ok if you configure your `wuic.properties` like this when you use `RequestDispatcherNutDao`:

----
c.g.wuic.computeVersionAsynchronously=false
c.g.wuic.engine.bestEffort=false
----

== Error codes

WUIC tries to clearly identify an error with a specific exception and a specific error code.
When an exception is thrown, you will see in the logs the code which is described http://wuic.github.io/apidocs/com/github/wuic/exception/ErrorCode.html[here].

If you have any suggestion about a more detailed code to be provided by WUIC, please http://wuic.github.io/contact.html[contact] us.

== Caching mechanism

Caching is a critical issue because it is often the most effective way to improve performances.
However, implementing a cache mechanism becomes tricky when we want to expose fresh data to the users.

WUIC helps developer to expose statics while taking advantage from caching on both server-side and client-side.
It also takes care of cache eviction when statics need to be refreshed.
This page introduces how WUIC does the trick.

=== Caching on server side

When a workflow is executed on server side, a set of statics are retrieved to be converted to treatable nuts.
The result is added to a cache which could be managed behind the scene by a `memory map` or then `EhCache` if you configured it.

Then, any other execution of the workflow will be faster because WUIC will use the cache to retrieve processed nuts.

To guarantee nuts freshness, you can obviously configure the cache with some settings to set a time to live or a time to idle.
However, this simple solution has its limitation.
Once you deployed your new statics, they will be ignored until the cache has expired.
Moreover, cache duration becomes a big problem since you may configure a high value (say 1 day) because you want that your application uses the cache as much as possible.

A better solution would be the <<tutorials.html#_monitor_changes,polling feature>>.
Here a thread will check any changes on set of statics at a configured interleave.
Nothing prevents you to poll your statics more regularly, say every 10 minutes.

TIP: it becomes interesting when you realize that WUIC triggers an event internally to evict the cache entry when any associated nut corresponds to an updated static.

=== Caching on client side

The HTTP protocol provides several directives to order caching to the browser.
We often talk about the http://en.wikipedia.org/wiki/Web_cache#Cache_control[cache control] header.
The `max-age` value defines how long the static should be kept before checking for new update.
The same problem on the server appears: you don't know how long the user will load an old version from browser cache until its expiry.
Consequently, you may probably set a short value.
When the statics expires, the browser sends a HTTP request to the server to know if the data is fresh or not.
If data is fresh, server responds with a status code `304 - not modified` and an empty body.
However, it sends the fresh data in the body.
What is unfortunate here is that the browser could poll the server synchronously and, at the end, see that nothing changed.
WUIC does not use the cache control for that reason.

The HTTP response should instead contains a "expires" directive which tells the browser to keep the statics for a very long time.
Since cache entry is associated the path URL of the static, WUIC has just to modify this path to evict the cache.
How it does the trick? By adding in the URL a version number identifying all nuts state processed by the workflow.
When nuts are changed, it could be detected on redeployment or during a polling operation.
Both cases will result in a different version number which will change the static URL, which does not corresponds to any cache entry on the browser.
This is the way WUIC prevent any unnecessary HTTP request on the server while maintaining fresh statics loaded by the browser.

In addition to the "expires" header, WUIC adds to the HTTP response an `ETag` containing the version number of the Nut.
When the browser is forced to reload the page, the `ETag` value is sent in the `If-None-Match` header of the HTTP request.
This value is compared to the actual nut's version number and if they equal, an empty content is sent with a `304 - not modified` status code.
This gives a chance to not always write the content to the HTTP response if the right content is already in the browser cache.

TIP: with HTTP/2 `server-push` is always initiated and stopped as soon as the browser has detected that the resource is actually cached.
With `resource-hint`, the browser will check first that resource is not cached before creating a new HTTP request.

==== Version strategy

Three strategies exist for computing the version number:

* `Last modification timestamp`: by default WUIC uses the last modification date associated to the resource on the disk.
It's fast, but if your build process touch the file, it will lead to a different version number while the content has not changed.
* `CRC32 content hash`: by setting the value `true` to the `c.g.wuic.dao.contentBasedVersionNumber` property, WUIC will read the entire content
to obtain a `CRC32` checksum. It's slower but you have the guarantee to keep intact the browser cache if you don't update the file
between two releases.
* `Fixed version number`: if you set a value for the `c.g.wuic.fixedVersionNumber` property, WUIC will always use this value as version number.
You can for instance use a version of your release.
This strategy will lead to a browser cache refresh each time you release a new version.
It requires to change the version yourself but this strategy allows to modified URL that can't be resolved.
For instance, if WUIC can't resolve a background url in a `CSS` file, it does not process the referenced image.
However it can at least add the fixed version number as a parameter to the URL (for instance `?versionNumber=20150808`).

== Best effort

By default at runtime, any cache `Engine` executes the entire workflow when the desired resources are not in the cache.
This operation takes time for the first user that retrieves its page.
You can consider that it won't be a problem since only the first user will be concerned.
However, WUIC comes with some possibilities to optimize this case.

First, WUIC can populate the cache for any `Nut` explicitly declared in your configuration point (for instance in your `wuic.xml` file) when your server starts.
This could be achieved with the following `context-param` in your `web.xml` file:

[source,xml]
----
    <context-param>
        <param-name>c.g.w.wuicWarmupStrategy</param-name>
        <param-value>SYNC</param-value>
    </context-param>
----

You can specify the `ASYNC` value instead of `SYNC` if you want that WUIC populates the cache in parallel of other components deployment to reduce startup time.

If WUIC discovers `Nut` on the fly by filtering HTML page with the `HtmlParserFilter` component, it can't know what to cache until a client sends the first HTTP request.
In that case, WUIC can do its best effort to deliver a response faster by applying synchronously only the mandatory operations.

You can enable this feature like that on your cache engine in your `wuic.properties` file:

[source]
----
c.g.wuic.engine.bestEffort=true
----

Mandatory operations are:

* CSS inspection to rewrite relative URL because they are served from a different location
* Image inspection to generate a sprite if configured
* Conversion of extended WEB language like `Typescript`

In best effort mode, all other operations (aggregation, compression) will be done asynchronously when the process result is not cached and the user will get its response faster.
Of course, the result won't be optimized but you'll still improve response time in that case.
Finally, once the asynchronous job will be done, cache will be updated and next requests will get transparently the full process result as configured.

== Feature comparison

=== Choose the right tool

WUIC provides several features to optimize your statics.
Choosing the right feature is important because they will have a different impact on your application in terms of:

* `Performances`: statics are optimized but an overhead can exist
* `Maintainability`: how you integrate the tool has an impact when you maintain your application
* `Scalability`: some compared feature can limit the power of WUIC, reducing the possibilities if you want to enhance your application

This document shows those differences to help you make the best choice.

=== Features overview

* `No-Tag`: just refer URL mapped to the WUIC servlet in your `<script>`, `<link>` and `<img>` elements when you write the HTML page
* `Per-Page-Configuration` with link:tutorials.html#_configure_resource_location_in_jsp[JSP] or link:tutorials.html#_create_your_template[Thymeleaf]
* `Startup-Configuration` (for instance with configuration in `wuic.xml`) with `JSP` or `Thymeleaf` support to write imports
* link:tutorials.html#_use_the_servlet_filter[Servlet-Filter]
* link:tutorials.html#_process_at_build_time[Build-Time]

++++
<table>
    <tr>
        <td><b>Feature</b></td>
        <td><b>Performance</b></td>
        <td><b>Maintain</b></td>
        <td><b>Scalable</b></td>
    </tr>
    <tr>
        <td><b><i>No-Tag</i></b></td>
        <td><b><i>Good</i></b></td>
        <td><b><i>Limited</i></b></td>
        <td><b><i>Limited</i></b></td>
    </tr>
    <tr>
        <td colspan="4">
            Full front-end development with no server-side page generation.
            It becomes necessary to re-deploy your application each time a new version needs to be published.
            You need also to evict by yourself browser cache.
        </td>
    </tr>
    <tr>
        <td><b><i>Startup-Configuration</i></b></td></td>
        <td><b><i>Good</i></b></td>
        <td><b<i>Good</i></b></td>
        <td><b><i>Good</i></b></td>
    </tr>
    <tr>
        <td colspan="4">Server-side page generation with all configurations in one location (wuic.xml)</td>
    </tr>
    <tr>
        <td><b><i>Per-Page-Configuration</i></b></td>
        <td><b><i>Limited</i></b></td>
        <td><b><i>Good</i></b></td>
        <td><b><i>Excellent</i></b></td>
    </tr>
    <tr>
        <td colspan="4">
            Server-side page generation with more configurations added in each page.
            Perfect when having a lot of pages with dedicated statics: it's more easy to declare them in the single page using it instead of declaring them in a big wuic.xml file.
            Configuration is discovered when user loads the page. "c.g.wuic.facade.multipleConfigInTagSupport" setting set to false helps to reduce response time.</td>
    </tr>
    <tr>
        <td><b><i>Servlet-Filter</i></b></td>
        <td><b><i>Limited</i></b></td>
        <td><b><i>Excellent</i></b></td>
        <td><b><i>Limited</i></b></td>
    </tr>
    <tr>
        <td colspan="4">
            Legacy pages that takes too much time to migrate to use tags.
            Statics are discovered when the user loads the page.
            Best effort mode can help to reduce response time.
        </td>
    </tr>
    <tr>
        <td><b><i>Build-Time</i></b></td>
        <td><b><i>Excellent</i></b></td>
        <td><b><i>Limited</i></b></td>
        <td><b><i>Good</i></b></td>
    </tr>
    <tr>
        <td colspan="4">
            Not necessary to reload statics at runtime.
            It becomes necessary to re-deploy your application each time a new version needs to be published.
        </td>
    </tr>
</table>

<!-- javascript
=================================================== -->
<!-- Placed at the end of the document so the pages load faster -->
<script src="http://code.jquery.com/jquery-1.10.0.min.js"></script>
<script src="bootstrap/js/bootstrap.js"></script>
<script type="text/javascript">
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-40383819-1', 'github.io');
    ga('send', 'pageview');
</script>
++++