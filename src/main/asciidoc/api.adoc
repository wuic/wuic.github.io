:toc: right

++++
    <!-- styles -->
    <link href="bootstrap/css/bootstrap.css" rel="stylesheet" />
    <link href="wiki-css/theme.css" rel="stylesheet" />
    <link href="bootstrap/css/bootstrap-responsive.css" rel="stylesheet" />
    <link href="font-awesome/css/font-awesome.css" rel="stylesheet" />

    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
    <script src="../assets/js/html5shiv.js"></script>
    <![endif]-->

    <!-- Favicon -->
    <link rel="shortcut icon" href="wiki-images/logo/favicon.ico" type="image/x-icon">
    <link rel="icon" href="wiki-images/logo/favicon.ico" type="image/x-icon">

    <div class="masthead">
        <div class="navbar">
            <div class="navbar-inner">
                <div class="container">
                    <ul class="nav" role="navigation">
                        <!-- Logo and slogan -->
                        <li><a href="index.html"><i class="icon-home"></i><span class="hidden-phone">&nbsp;Home</span></a></li>
                        <li><a href="project.html"><i class="icon-star"></i><span class="hidden-phone">&nbsp;Project</span></a></li>
                        <li class="active"><a href="wuic-documentation.html"><i class="icon-book"></i><span class="hidden-phone">&nbsp;Documentation</span></a></li>
                        <li><a href="contact.html"><i class="icon-envelope"></i><span class="hidden-phone">&nbsp;Contact</span></a></li>
                        <li><a href="https://github.com/wuic/wuic" target="_blank" title="Wuic Github"><i class="icon-github"></i><span class="hidden-phone">&nbsp;Github</span></a></li>
                        <li><a href="https://twitter.com/wuic_project" target="_blank"><i class="icon-twitter"></i><span class="hidden-phone">&nbsp;Twitter</span></a></li>
                    </ul>
                </div>
            </div>
        </div><!-- /.navbar -->
    </div>
++++

IMPORTANT: for deep understanding of settings purpose declared in `web.xml`, you should take a look at the link:design.htm[WUIC configuration design].

== Configuring the wuic.xml or the wuic.json

The table bellow describes each tag and their hierarchy in the `wuic.xml` (for XML) and `wuic.json` (for JSON) file:

++++
<table>
  <tr>
    <td>Root</td>
    <td>Level 0</td>
    <td>Level 1</td>
    <td>Level 2</td>
    <td>Level 3</td>
  </tr>
  <tr>
    <td><a href="#_wuic">wuic</a></td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td>|____</td>
    <td><a href="#_nut-dao-builders">nut-dao-builders</a></td>
    <td></td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td>|</td>
    <td>|_________</td>
    <td><a href="#_nut-dao-builder">nut-dao-builder</a></td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td>|</td>
    <td></td>
    <td>|_________</td>
    <td><a href="#_properties">properties</a></td>
    <td></td>
  </tr>
  <tr>
    <td>|</td>
    <td></td>
    <td></td>
    <td>|_________</td>
    <td><a href="#_property">property</a></td>
  </tr>
<tr>
    <td>|____</td>
    <td><a href="#_nut-filter-builders">nut-filter-builders</a></td>
    <td></td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td>|</td>
    <td>|_________</td>
    <td><a href="#_nut-filter-builder">nut-filter-builder</a></td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td>|</td>
    <td></td>
    <td>|_________</td>
    <td><a href="#_properties">properties</a></td>
    <td></td>
  </tr>
  <tr>
    <td>|</td>
    <td></td>
    <td></td>
    <td>|_________</td>
    <td><a href="#_property">property</a></td>
  </tr>
  <tr>
    <td>|____</td>
    <td><a href="#_heaps">heaps</a></td>
    <td></td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td>|</td>
    <td>|_________</td>
    <td><a href="#_heap">heap</a></td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td>|</td>
    <td></td>
    <td>|_________</td>
    <td><a href="#_nut-path">nut-path</a></td>
    <td></td>
  </tr>
  <tr>
    <td>|</td>
    <td></td>
    <td>|_________</td>
    <td><a href="#_heap-id">heap</a></td>
    <td></td>
  </tr>
  <tr>
    <td>|</td>
    <td></td>
    <td>|_________</td>
    <td><a href="#_heap">heap-id</a></td>
    <td></td>
  </tr>
  <tr>
    <td>|____</td>
    <td><a href="#_engine-builders">engine-builders</a></td>
    <td></td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td>|</td>
    <td>|_________</td>
    <td><a href="#_engine-builder">engine-builder</a></td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td>|</td>
    <td></td>
    <td>|_________</td>
    <td><a href="#_properties">properties</a></td>
    <td></td>
  </tr>
  <tr>
    <td>|</td>
    <td></td>
    <td></td>
    <td>|_________</td>
    <td><a href="#_property">property</a></td>
  </tr>
  <tr>
    <td>|____</td>
    <td><a href="#_workflow-templates">workflow-templates</a></td>
    <td></td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td></td>
    <td>|_________</td>
    <td><a href="#_workflow-template">workflow-template</a></td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td>|_________</td>
    <td><a href="#_engine-chain">engine-chain</a></td>
    <td></td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td></td>
    <td>|_________</td>
    <td><a href="#_engine-builder-id">engine-builder-id</a></td>
  </tr>
  <tr>
    <td>|____</td>
    <td><a href="#_workflows">workflows</a></td>
    <td></td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td></td>
    <td>|_________</td>
    <td><a href="#_workflow">workflow</a></td>
    <td></td>
    <td></td>
  </tr>
</table>
++++

=== wuic

This is simply the root tag, http://www.youtube.com/watch?v=x7bIbVlIqEc[nothing else matter] ;-)

[source,xml]
----
<wuic>
    ...
</wuic>
----

Alternatively in JSON:

[source,json]
----
{
    ...
}
----

=== nut-dao-builders

The NutDao builders usable in the context. Each builder will be usable from the link:#heap[heap].

[source,xml]
----
<wuic>
    <nut-dao-builders>
        ...
    </nut-dao-builders>
</wuic>
----

Alternatively in JSON:

[source,json]
----
{
    "nutDaoBuilders" : [{ ... }]
}
----

==== nut-dao-builder

Each builder creates a `NutDao` thanks to a set of properties.
When a factory is created, it is used to build NutDao thanks to a `String` representation of its path.
Defines an unique ID to be referenced somewhere else.

When WUIC link:#profiles_prop[is activated with some profiles], multiple declarations with the same ID are allowed if duplicated registrations can be eliminated.
Profiles are declared through the `profiles` attribute. Also declares the class name as a `type` attribute.

Finally, an optional regex attribute could be specified (default value is false).
If true, the nut names must be a compilable http://docs.oracle.com/javase/1.4.2/docs/api/java/util/regex/Pattern.html[pattern].

[source,xml]
----
<wuic>
    <nut-dao-builders>
        <nut-dao-builder id="http-resource-builder" type="HttpNutDaoBuilder" profiles"foo,bar">
            ...
        <nut-dao-builder>
    </nut-dao-builders>
</wuic>
----

Alternatively in JSON:

[source,json]
----
{
    "nutDaoBuilders" : [{
        "id" : "http-resource-builder",
        "type" : "HttpNutDaoBuilder"
        "profiles" : ["foo", "bar"]
    }]
}
----

TIP: `id` attribute is optional. If not set, the properties will be applied to the default instance of the `type`.

TIP: `type` attribute is optional. The default value is `ClasspathNutDaoBuilder` (for classpath access).

=== nut-filter-builders

The NutFilter builders usable in the context. Each builder will be used inside the context

[source,xml]
----
<wuic>
    <nut-filter-builders>
        ...
    </nut-filter-builders>
</wuic>
----

Alternatively in JSON:

[source,json]
----
{
    "nutFilterBuilders" : [{ ... }]
}
----

==== nut-filter-builder

Each builder creates a NutFiler thanks to a set of properties. Objects are built thanks to a String representation of its path.
Defines an unique ID to be referenced somewhere else. Also declares the class name as a `type` attribute.
When any link:#heap[heap] is built from the context, its paths are previously filtered with all defined filters.

When WUIC link:#profiles_prop[is activated with some profiles], multiple declarations with the same ID are allowed if duplicated registrations can be eliminated.
Profiles are declared through the `profiles` attribute. Also declares the class name as a `type` attribute.

[source,xml]
----
<wuic>
    <nut-filter-builders>
        <nut-filter-builder id="remove-regex-filter-builder" type="RegexRemoveNutFilterBuilder" profiles="foo,bar">
            ...
        <nut-filter-builder>
    </nut-filter-builders>
</wuic>
----

Alternatively in JSON:

[source,json]
----
{
    "nutFilterBuilders" : [{
        "id" : "remove-regex-filter-builder",
        "type" : "RegexRemoveNutFilterBuilder",
        "profiles" : ["foo", "bar"]
    }]
}
----

TIP: `id` attribute is optional. If not set, the properties will be applied to the default instance of the component indicated in the `type`.

=== engine-builders

Defines the engine builders usable in any workflow.

[source,xml]
----
<wuic>
   <engine-builders>
       ...
   </engine-builders>
</wuic>
----

Alternatively in JSON:

[source,json]
----
{
   "engineBuilders" : [{ ... }]
}
----

==== engine-builder

An EngineBuilder is always identified by an unique ID to be referenced somewhere else. Also
defines the class to be instantiated.

When WUIC link:#profiles_prop[is activated with some profiles], multiple declarations with the same ID are allowed if duplicated registrations can be eliminated.
Profiles are declared through the `profiles` attribute. Also declares the class name as a `type` attribute.

[source,xml]
----
<wuic>
   <engine-builders>
       <engine-builder id="yuicomspressor-js" type="YuiCompressorJavascriptEngineBuilder" profiles="foo,bar" />
   </engine-builders>
</wuic>
----

Alternatively in JSON:

[source,json]
----
{
   "engineBuilders" : [{
        "id" : "yuicomspressor-js",
        "type" : "YuiCompressorJavascriptEngineBuilder"
        "profiles" : ["foo", "bar"]
   }]
}
----

TIP: `id` attribute is optional. If not set, the properties will be applied to the default instance of the component indicated in the `type`.
Note that default instances are injected by default in any workflow.

==== properties

The properties define a list of settings for both `nut-dao-builder` and `engine-builder` elements.

[source,xml]
----
<wuic>
    <nut-filter-builders>
        <nut-filter-builder id="remove-regex-filter-builder" type="RegexRemoveNutFilterBuilder">
            <properties>
                ...
            <properties>
        <nut-dao-builder>
    </nut-filter-builders>
</wuic>
----

or

[source,xml]
----
<wuic>
    <nut-dao-builders>
        <nut-dao-builder id="http-resource-builder" type="HttpNutDaoBuilder">
            <properties>
                ...
            <properties>
        <nut-dao-builder>
    </nut-dao-builders>
</wuic>
----

or

[source,xml]
----
<wuic>
    <engine-builders>
        <engine-builder id="jsSprite" type="ImageAggregatorEngineBuilder">
            <properties>
                ...
            </properties>
        </engine-builder>
    </engine-builders>
</wuic>
----

Alternatively in JSON:

[source,json]
----
{
    "nutFilterBuilders" : [{
        "id" : "remove-regex-filter-builder",
        "type" : "RegexRemoveNutFilterBuilder",
        "properties" : { ... }
    }]
}
----

or

[source,json]
----
{
    "nutDaoBuilders" : [{
        "id" : "http-resource-builder",
        "type" : "HttpNutDaoBuilder",
        "properties" : { ... }
    }]
}
----

or

[source,json]
{
   "engineBuilders" : [{
        "id" : "yuicomspressor-js",
        "type" : "YuiCompressorJavascriptEngineBuilder",
        "properties" : { ... }
   }]
}
----

==== property

A property used to initialize the builder. Defines a `key` attribute and a `value` as a child node.

[source,xml]
----
<wuic>
    <nut-filter-builders>
        <nut-filter-builder id="remove-regex-filter-builder" type="RegexRemoveNutFilterBuilder">
            <properties>
                <property key="c.g.wuic.filter.regexExpressions">.*debug.*</property>
            <properties>
        <nut-dao-builder>
    </nut-filter-builders>
</wuic>
----

or

[source,xml]
----
<wuic>
    <nut-dao-builders>
        <nut-dao-builder id="http-resource-builder" type="HttpNutDaoBuilder">
            <properties>
                <property key="c.g.wuic.httpServerDomain">gdrouet.github.io</property>
                <property key="c.g.wuic.httpBasePath">wuic</property>
            <properties>
        <nut-dao-builder>
    </nut-dao-builders>
</wuic>
----

or

[source,xml]
----
<wuic>
    <engine-builders>
        <engine-builder id="jsSprite" type="ImageAggregatorEngineBuilder">
            <properties>
                <property key="c.g.wuic.engine.spriteProviderClassName">javascript</property>
            </properties>
        </engine-builder>
    </engine-builders>
</wuic>
----

Alternatively in JSON:

[source,json]
----
{
    "nutFilterBuilders" : [{
        "id" : "remove-regex-filter-builder",
        "type" : "RegexRemoveNutFilterBuilder",
        "properties" : {
            "c.g.wuic.filter.regexExpressions" : ".*debug.*"
        }
    }]
}
----

or

[source,json]
----
{
    "nutDaoBuilders" : [{
        "id" : "http-resource-builder",
        "type" : "HttpNutDaoBuilder",
        "properties" : {
            "c.g.wuic.httpServerDomain" : "gdrouet.github.io",
            "c.g.wuic.httpBasePath" : "wuic"
        }
    }]
}
----

or

[source,json]
{
   "engineBuilders" : [{
        "id" : "yuicomspressor-js",
        "type" : "YuiCompressorJavascriptEngineBuilder",
        "properties" : {
            "c.g.wuic.engine.spriteProviderClassName" : "javascript"
        }
   }]
}
----

Note: you can use the `${myProperty:myDefaultValue}` notation to inject a property value declared anywhere (like in `wuic.properties` or `web.xml` init-param).
In the example above, if the `myProperty` is not found then the `myDefaultValue` will be applied.
Specifying a default value is optional, meaning you can write `${myProperty}`.

=== heaps

Defines the different heaps of nuts you can load in your application.

[source,xml]
----
<wuic>
    <heaps>
        ...
    </heaps>
</wuic>
----

Alternatively in JSON:

[source,json]
----
{
    "heaps" : [{ ... }]
}
----

==== heap

A heap is identified by an unique ID and must defines a builder to use (`dao-builder-id attribute`).
The builder is referenced thanks to its ID.

When WUIC link:#profiles_prop[is activated with some profiles], multiple declarations with the same ID are allowed if duplicated registrations can be eliminated.
Profiles are declared through the `profiles` attribute. Also declares the class name as a `type` attribute.

[source,xml]
----
<wuic>
    <heaps>
        <heap id="common-js" dao-builder-id="classPathBuilder" profiles="foo,bar">
            ...
        </heap>
    </heaps>
</wuic>
----

Alternatively in JSON:

[source,json]
----
{
    "heaps" : [{
        "id" : "common-js",
        "daoBuilderId" : "classPathBuilder",
        "profiles" : ["foo", "bar"]
    }]
}
----

TIP: `dao-builder-id` is optional. By default, the default `ClasspathNutDaoBuilder` will be used.

==== nut-path

The `nut-path` defines the path that allows to access a nut has child node.
Finally, you can represent a set of nuts if your associated DAO considers paths as regex.

[source,xml]
----
<wuic>
    <heaps>
        <heap id="common-js" default-builder="classPathBuilder">
            <nut-path>/js/common.js</nut-path>
            <nut-path>/js/misc/*.js</nut-path>
        </heap>
    </heaps>
</wuic>
----

Alternatively in JSON:

[source,json]
----
{
    "heaps" : [{
        "id" : "common-js",
        "daoBuilderId" : "classPathBuilder",
        "nutPath" : ["/js/common.js", "/js/misc/*.js"]
    }]
}
----

==== heap-id

Your heap could be a composition of another heaps.
Inside a heap, you can refer an existing one with `heap-id` or declare a new heap on the fly.

[source,xml]
----
<wuic>
    <heaps>
        <heap id="homepage-js" dao-builder-id="classPathBuilder">
           <heap-id>common-js</heap-id>
           <heap id="content-js" dao-builder-id="http-resource-builder">
               <nut-path>http://com.myapp/js/foo.js</nut-path>
           </heap>
           <nut-path>js/bar.js</nut-path>
        <heap>
    </heaps>
</wuic>
----

Alternatively in JSON:

[source,json]
----
{
    "heaps" : [{
        "id" : "homepage-js",
        "daoBuilderId" : "classPathBuilder",
        "heapId" : ["common-js"],
        "heap" : {
            "id" : "content-js",
            "daoBuilderId" : "http-resource-builder"
            "nutPath" : ["http://com.myapp/js/foo.js"]
        },
        "nutPath" : "js/bar.js"
    }]
}
----

WARNING: nuts retrieved from `nut-path` are always read before nuts retrieved from nested and referenced heaps.
If order matter, you should not mix `nut-path` with heaps and only use `heap` and `heap-id` to preserve order.

=== workflow-templates

The workflow templates describe the way the nut could be processed.

[source,xml]
----
<wuic>
    <workflow-templates>
           ...
    </workflow-templates>
</wuic>
----

Alternatively in JSON:

[source,json]
----
{
    "workflowTemplates" : [{ ... }]
}
----

==== workflow-template

The workflow template is declared to contain a list of engines. It is identified with an unique ID.

Below, the example shows that a workflow template will be created and identified with `tpl` ID.

When WUIC link:#profiles_prop[is activated with some profiles], multiple declarations with the same ID are allowed if duplicated registrations can be eliminated.
Profiles are declared through the `profiles` attribute. Also declares the class name as a `type` attribute.

[source,xml]
----
<wuic>
    <workflow-templates>
        <workflow-template id="tpl" profiles="foo,bar">
            ...
        </workflow-template>
    </workflow-templates>
</wuic>
----

Alternatively in JSON:

[source,json]
----
{
    "workflowTemplates" : [{
        "id" : "tpl",
        "profiles" : ["foo", "bar"]
    }]
}
----

==== engine-chain

The engines chain will refers all the engines to use when processing the workflow.
They could be specified in any order, WUIC will order them by kind, especially to guarantee that cache engine will be at the head of the chain.

[source,xml]
----
<wuic>
    <workflow-templates>
        <workflow-template id-prefix="js-image" heap-id-pattern="sprite-">
            <engine-chain>
                ...
            </engine-chain>
        </workflow-template>
    </workflow-templates>
</wuic>
----

Alternatively in JSON:

[source,json]
----
{
    "workflowTemplates" : [{
        "idPrefix" : "js-image",
        "heapIdPattern" : "sprite-",
        "engineChain" : ...
    }]
}
----

==== engine-builder-id

The engine-builder-id contains has child text node the ID of an existing engine builder to be added in the chain of responsibility executed by the workflow.

[source,xml]
----
<wuic>
    <workflow-templates>
        <workflow-template id-prefix="js-image" heap-id-pattern="sprite-">
            <engine-chain>
                <engine-builder-id>jsSprite</engine-builder-id>
            </engine-chain>
        </workflow-template>
    </workflow-templates>
</wuic>
----

Alternatively in JSON:

[source,json]
----
{
    "workflowTemplates" : [{
        "idPrefix" : "js-image",
        "heapIdPattern" : "sprite-",
        "engineChain" : ["jsSprite"]
    }]
}
----

=== workflows

The workflows are the bridge between the heaps and the workflow template that list the engines to use.

[source,xml]
----
<wuic>
    <workflows>
           ...
    </workflows>
</wuic>
----

Alternatively in JSON:

[source,json]
----
{
    "workflows" : [{ ... }]
}
----

==== workflow

The workflow is declared to be applied on a set of heaps described with the `heap-id-pattern` property interpreted as a regex.
Each heap's name matching the regex will be associated to a workflow identified by the heap name and eventually a prefix specified in `id-prefix` property.

The workflow is always built on top of a template referenced with `workflow-template-id` property.

When WUIC link:#profiles_prop[is activated with some profiles], multiple declarations with the same ID are allowed if duplicated registrations can be eliminated.
Profiles are declared through the `profiles` attribute. Also declares the class name as a `type` attribute.

Below, the example shows that a workflow will be created for each heap with a name containing `image` word.
Those workflows will be named with a string starting with `sprite-`.

[source,xml]
----
<wuic>
    <workflows>
        <workflow id-prefix="sprite-" workflow-template-id="tpl" heap-id-pattern=".*image" profiles="foo,bar" />
    </workflows>
</wuic>
----

Alternatively in JSON:

[source,json]
----
{
    "workflows : [{
        "idPrefix" : "sprite-",
        "workflowTemplateId" : "tpl",
        "heapIdPattern" : ".*image",
        "profiles" : ["foo", "bar"]
    }]
}
----

Another possibility is to replace `id-prefix` attribute by an `id` attribute.
In this case, only one workflow is created identified by the value in the `id` attribute.
This workflow is associated to a heap which is a composition of all heaps with an ID matching the `heap-id-pattern` attribute regex value.

[source,xml]
----
<wuic>
    <workflows>
        <workflow id="workflow" workflow-template-id="tpl" heap-id-pattern=".*image" />
    </workflows>
</wuic>
----

Alternatively in JSON:

[source,json]
----
{
    "workflows" : [{
        "id" : "workflow",
        "workflowTemplateId" : "tpl",
        "heapIdPattern" : ".*image"
    }]
}
----

== Using profiles

WUIC to segregate parts of your configurations and make it only available in certain environments.
The main configurable components in WUIC are `NutDao`, `Engine`, `NutFilter`, `Heap`, `Templates` and `Worfklow`.

Any registration can be marked with a profile to limit when it is loaded:

[source,xml]
----
<wuic>
    <workflows>
        <workflow id="workflow" profiles="my-profile" workflow-template-id="tpl" heap-id-pattern=".*image" />
    </workflows>
</wuic>
----

Alternatively in JSON:

[source,json]
----
{
    "workflows" : [{
        "id" : "workflow",
        "workflowTemplateId" : "tpl",
        "heapIdPattern" : ".*image",
        "profiles": ["my-profile"]
    }]
}
----

You can use a link:#profiles_prop[property] to specify which profiles are active.
You can specify the property in any of the usual ways, for example you could include it in your `wuic.properties` file or as a JVM property.

Registrations are always identified with an ID but can share the same value if they have different profiles.
When a WUIC context is created, registrations are excluded according to activated profiles.
If there is still more than one applicable registration for a given ID, WUIC will raise an error.

For instance, if `foo` or `bar` profile is enabled, the following configuration is fine:

[source,xml]
----
<wuic>
    <workflows>
        <workflow id="workflow" profiles="foo" workflow-template-id="tpl1" heap-id-pattern=".*image" />
        <workflow id="workflow" profiles="bar" workflow-template-id="tpl2" heap-id-pattern=".*image" />
    </workflows>
</wuic>
----

However, if no profile is active or if both `foo` and `bar` profiles are activated, two registrations are identified with `workflow`, which is not accepted.

== Configuring WUIC components

=== Configuring the engines

Engines could be configured with specific properties used to define an engine builder. In XML, this looks like this:

[source,xml]
----
    <engine-builders>
        <engine-builder id="jsSprite" type="ImageAggregatorEngineBuilder">
            <properties>
                <property key="c.g.wuic.engine.spriteProviderClassName">javascript</property>
            </properties>
        </engine-builder>
    </engine-builders>
----

In JSON:

[source,json]
----
    "engineBuilders" : [{
        "id" : "jsSprite",
        "type" : "ImageAggregatorEngineBuilder",
        "properties" : {
            "c.g.wuic.engine.spriteProviderClassName" : "javascript"
        }
    }]
----

The possible properties for an engine are tightly coupled to the underlying project and its purpose.

IMPORTANT: if you're going to configure an engine provided by an extension, make sure the dependency has been added to your pom.xml!
Find available extensions https://github.com/wuic/wuic-extensions[here]

Here is the list of all possible properties for each engine builder.
Find description of each property http://wuic.github.io/apidocs/constant-values.html#com.github.wuic.ApplicationConfig[here]

++++
include::{table-repository}com.github.wuic.engine.html[]
++++

=== Configuring the NutDao

There are several ways to access resources:

* inside your webapp (Classpath, WAR, RequestDispatcher, WebJar)
* or outside (FTP, HTTP, SSH, etc)

WUIC access provides support for each protocol.
A protocol is wrapped by a `NutDao` implementation which is built thanks to a `NutDaoBuilder` implementation.
You can choose to use a protocol when you refer a `NutDaoBuilder` in your heap.
In your `wuic.xml`, you will declare it like this:

[source,xml]
----
    <nut-dao-builder id="sourceRootProvider" class="ClasspathNutDaoBuilder" />
----

Or in your `wuic.json`:

[source,json]
----
{
    "id" : "sourceRootProvider",
    "class" : "ClasspathNutDaoBuilder"
}
----

Here are the possible classes for each protocol:

* RequestDispatcher: `RequestDispatcherNutDaoBuilder` (typically for statics under `src/main/webapp`)
* Classpath: `ClasspathNutDaoBuilder` (typically for statics under `src/main/resources`)
* Webapp: `WebappNutDaoBuilder` (typically for statics under `src/main/webapp/WEB-INF` except `src/main/webapp/WEB-INF/lib` which is ignored)
* WebJar: `WebJarNutDao` (for statics packages inside http://www.webjars.org[webjars] dependencies)
* Spring: `SpringNutDao` (for resources resolved via http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/context/support/ServletContextResourcePatternResolver.html[ServletContextResourcePatternResolver])
* HTTP: `HttpNutDaoBuilder`
* SSH: `SshNutDaoBuilder`
* FTP: `FtpNutDaoBuilder`
* Disk: `DiskNutDaoBuilder`
* Amazon S3: `S3NutDaoBuilder`
* Google Storage: `GStorageNutDaoBuilder`

IMPORTANT: if you're going to configure a DAO provided by an extension, make sure the dependency has been added to your `pom.xml`!
Find available extensions https://github.com/wuic/wuic-extensions[here]

Each time you specify a class, you can override its default properties.
For instance, you will override the FTP domain server like this:

[source,xml]
----
    <nut-dao-builder id="sourceRootProvider" class="FtpNutDaoBuilder">
        <property key="c.g.wuic.serverDomain">mycompany.com</property>
    </nut-dao-builder>
----

Alternatively in JSON:

[source,json]
----
{
    "id" : "sourceRootProvider",
    "class" : "FtpNutDaoBuilder",
    "properties" : {
        "c.g.wuic.serverDomain" : "mycompany.com"
    }
}
----

Not all properties are supported by each builder. Here is a table which describe them and their support by builder.

Note: you can find description of each property http://wuic.github.io/apidocs/constant-values.html#com.github.wuic.ApplicationConfig[here]

++++
include::{table-repository}com.github.wuic.nut.dao.html[]
++++

=== Configuring the NutFilter

In some context, you might want to remove some nuts from the declared heap.
For instance, you can add debug files to your page to be removed once you are in production.
Filters like `RegexRemoveNutFilterBuilder` can help you if you enable them.
They can remove some of the nuts once without the need to do it manually.

In XML, configuring a filter looks like this:

[source,xml]
----
    <nut-filter-builder id="regexRemoveNutFilter" type="RegexRemoveNutFilterBuilder">
        <properties>
            <property key="c.g.wuic.filter.regexExpressions">
                .*.js
                ref.css
            </property>
        </properties>
    </nut-filter-builder>
----

In JSON:

[source,json]
----
{
    "id" : "regexRemoveNutFilter",
    "type" : "RegexRemoveNutFilterBuilder"
    "properties" : {
        "c.g.wuic.filter.regexExpressions" : ".*.js\nref.css"
    }
}
----

IMPORTANT: please note that filters are global and apply to all declared heaps.

Not all properties are supported by each builder. Here is a table which describe them and their support by builder.

Note: you can find description of each property http://wuic.github.io/apidocs/constant-values.html#com.github.wuic.ApplicationConfig[here]

++++
include::{table-repository}com.github.wuic.nut.filter.html[]
++++

=== Intercept component creation

When WUIC instantiates all its components, a list of registered `ObjectBuilderInspector` is chained and called to
modify the instance. The interface corresponds to the following code:

[source,java]
----
public interface ObjectBuilderInspector {
    <T> T inspect(T object);
}
----

Any instance can be registered:

* By declaring the class names in <<Configuring the web.xml, web.xml configuration>>.
* By relying on http://docs.oracle.com/javase/7/docs/api/java/util/ServiceLoader.html[ServiceLoader].
This can be achieved by creating a file that contains the class names of different implementations and called
`META-INF/services/com.github.wuic.config.ObjectBuilderInspector`.

By default, any object is inspected. If you want to specify for which type of object your inspector is supposed to be
invoked, you can annotate your class with the `@InspectedType` annotation like this:

[source,java]
----
include::{wuic-repository}wuic/core/src/test/java/com/github/wuic/test/ctx/ContextBuilderTest.java[tags=InspectBarAndFoo]
----

In this example, any created object will be inspected by the inspector if it IS-A `Foo` or `Bar`.

Moreover, you can restrict the execution of any `ObjectBuilderInspector` if you annotate it with `com.github.wuic.Profile` annotation.

[source,java]
----
include::{wuic-repository}wuic/core/src/test/java/com/github/wuic/test/ctx/ContextBuilderTest.java[tags=ObiProfile]
----

== Configuring the web.xml

=== Introduction

Basic use case is to use WUIC inside a servlet container configured traditionally with a `web.xml` file.
This documentation described how to configure three main components:

* `WuicServletContextListener`: the listener that bootstraps WUIC
* `HtmlParserFilter`: the filter that optimizes HTML pages
* `WuicServlet`: the servlet that served the statics

=== Configuring the ContextListener

`wuic-servlet.jar` contains a `ContextListener` annotated with the servlet 3 `@WebListener` annotation and allows WUIC to bootstrap.

You can configure the execution of the listener with the following `context-param`.

Reminder for default implementation:

[source,xml]
----
    <context-param>
        <param-name>your param name</param-name>
        <param-value>your param value</param-value>
    </context-param>
----

Note: you can use as `param-value` the `${myProperty:myDefaultValue}` notation to inject a property value declared anywhere
(like in `wuic.properties` or `web.xml` init-param).
In the example above, if the `myProperty` is not found then the `myDefaultValue` will be applied.
Specifying a default value is optional, meaning you can write `${myProperty}`.

*Note for those who don't want to use init-param:*
you will see the particular `c.g.wuic.initParameterClass` `init-param` in the table below.
If you want to provide parameters in a different way, specify an implementation of `com.github.wuic.util.PropertyResolver`.
This is a simple interface that provides a set of keys for which it's able to return an associated value (key-value pair).
If you set this `init-param`, no other `init-param` with a key mentioned bellow will be interpreted since your implementation will be used.

In the `Parameter name` column bellow, replace the first `*` character from all keys and replace it with `c.g.wuic`.

++++
<table>
    <tr>
        <td>Parameter name</td>
        <td>Description</td>
        <td>Default value</td>
    </tr>
    <tr>
        <td>*.facade.wuicContextPath</td>
        <td>Virtual base path for any nut name</td>
        <td>Empty string</td>
    </tr>
    <tr>
        <td>*.facade.wuicXmlPath</td>
        <td>String used to build a `java.net.URL` expected to point to a `wuic.xml` file</td>
        <td>/wuic.xml in the classpath</td>
    </tr>
    <tr>
        <td>*.facade.wuicXmlPathAsSystemProperty</td>
        <td>Considers the `c.g.wuic.facade.wuicXmlPath` as a system property to get to build the URL</td>
        <td>false</td>
    </tr>
    <tr>
        <td>*.facade.propertiesPath</td>
        <td>String used to build a `java.net.URL` expected to point to a `wuic.properties` file</td>
        <td>/wuic.properties in the classpath</td>
    </tr>
    <tr>
        <td>*.facade.propertiesPathAsSystemProperty</td>
        <td>Considers the `c.g.wuic.facade.propertiesPath` as a system property to get to build the URL</td>
        <td>false</td>
    </tr>
    <tr>
        <td>*.facade.useDefaultContextBuilderConfigurators</td>
        <td>Injects in WUIC the default builders to have basic `NutDao` and `Engine` available during configuration</td>
        <td>true</td>
    </tr>
    <tr>
        <td>*.facade.additionalBuilderConfiguratorClasses</td>
        <td>
            List of comma-separated class names extending <a href="http://wuic.github.io/apidocs/index.html?com/github/wuic/ContextBuilderConfigurator.html">ContextBuilderConfigurator</a>
            that will be used in the facade.
        </td>
        <td>Empty string</td>
    </tr>
    <tr>
        <td>*.facade.additionalBuilderInspectorClasses</td>
        <td>
            List of comma-separated class names extending <a href="http://wuic.github.io/apidocs/index.html?com/github/wuic/config/ObjectBuilderInspector.html">ObjectBuilderInspector</a>
            that will be used in the facade.
        </td>
        <td>Empty string</td>
    </tr>
    <tr>
         <td>*.facade.wuicMultipleConfigInTagSupport</td>
         <td>For tag support (Thymeleaf, JSP, etc): tell to parse the configuration every time the tag is run</td>
         <td>false</td>
    </tr>
    <tr>
         <td>*.facade.wuicWarmupStrategy</td>
         <td>When a context is built, a warmup strategy could be specified run all known workflows asynchronously (`ASYNC`), synchronously (`SYNC`) or not (`NONE`)</td>
         <td>NONE</td>
    </tr>
    <tr>
         <td id="profiles_prop">*.facade.profiles</td>
         <td>Activated profiles in WUIC that will be used to filter registrations.</td>
         <td>Empty String</td>
    </tr>
    <tr>
         <td>*.facade.defaultNutDaoClass</td>
         <td>When no `NutDao` type or ID is specified in a component settings, WUIC will apply this default component with a default configuration.</td>
         <td>com.github.wuic.nut.dao.core.ClasspathNutDao</td>
    </tr>
    <tr>
         <td>*.charset</td>
         <td>
            Charset used by WUIC when reading/writing files.
            By default the charset is an empty string.
            In that case, WUIC will use <code>Charset.defaultCharset()</code> to retrieve a valid value.
            This means that by default the charset is platform dependent.
            Define explicitly a a value in your configuration file let WUIC consider the same charset across different environment.
            Another solution is to define the system property <code>file.encoding</code> in the JVM settings of each environment where WUIC is running.</td>
         <td>Empty string</td>
    </tr>
    <tr>
         <td>*.initParameterClass</td>
         <td>Indicates the com.github.wuic.util.PropertyResolver implementation which retrieves a value for a given parameter. Of course, default implementation relies on init-param in web.xml file.</td>
         <td>Internal InitParamProperties class</td>
    </tr>

</table>
++++

=== Configuring the WuicServlet

If you want to serve directly the statics from your webapp, you need to configure the servlet:

[source,xml]
----
    <servlet>
        <description>WUIC servlet</description>
        <servlet-name>wuic</servlet-name>
        <servlet-class>com.github.wuic.servlet.WuicServlet</servlet-class>
        <load-on-startup>1</load-on-startup>
    </servlet>
    <servlet-mapping>
        <servlet-name>wuic</servlet-name>
        <url-pattern>/wuic/*</url-pattern>
    </servlet-mapping>
----

=== Configuring the HtmlParserFilter

WARNING: parsing the HTML takes time.
You should enable the link:reference.html#_best_effort[best effort mode]: if the HTML has been parsed before and the result still exists in the cache, it applies replacements.
However, it just return the unparsed HTML to deliver as fast as possible the response and process scripts asynchronously.

==== Install the filter

If your pages are served from your application server, you can filter them with the HTML filter:

[source,xml]
----
<filter>
    <filter-name>htmlParserFilter</filter-name>
    <filter-class>com.github.wuic.servlet.HtmlParserFilter</filter-class>
</filter>

<filter-mapping>
    <filter-name>htmlParserFilter</filter-name>
    <url-pattern>/html/*</url-pattern>
</filter-mapping>
----

Do not forget to add the following maven dependencies:

[source,xml]
----
     <dependency>
         <groupId>com.github.wuic</groupId>
         <artifactId>wuic-servlet</artifactId>
         <version>${wuic.version}</version>
      </dependency>

      <dependency>
          <groupId>com.github.wuic.extensions</groupId>
          <artifactId>wuic-attoparser</artifactId>
          <version>${wuic.version}</version>
      </dependency>
----

The first one contains the `Filter`.
This library does not embeds parser capabilities and is not able to discover web resources to be optimized.
This is why we install an second dependency that is an extension comming with this kind of parser.

==== Supported settings

++++
<table>
    <tr>
        <td>Parameter name</td>
        <td>Description</td>
        <td>Default value</td>
    </tr>
    <tr>
        <td>c.g.wuic.filter.disableServerPush</td>
        <td>Never use HTTP/2 server-push even if possible and use server-hints instead</td>
        <td>false</td>
    </tr>
    <tr>
        <td>c.g.wuic.forceDynamicContent</td>
        <td>Always consider the filtered HTML as dynamic instead of checking if tag support (JSP or Thymeleaf) has been used to generate the response</td>
        <td>false</td>
    </tr>
</table>
++++

==== Extend the filter

===== Custom DAO

By default WUIC uses a `RequestDispatcherNutDao`.
The http://wuic.github.io/apidocs/com/github/wuic/servlet/HtmlParserFilter.html[javadoc] describes how you can extend the
filter to specify another DAO or even a complete chain of engines to use. Note that if you use `FilterRegistration` then
you can instantiate the class with different constructors instead of using the default one.

===== Custom page identification

IMPORTANT: WUIC computes an unique ID for each filtered page.
For each ID, WUIC will associate all the filtered statements and cache them.
This means that if two pages lead to the same ID, you will start facing weird issues.
By default, the servlet path is used to compute the ID. If other discriminators are used, you can create a class
that extends the `HtmlParserFilter` and override it like that:

[source,java]
----
include::{wuic-repository}wuic/servlet/src/test/java/com/github/wuic/servlet/test/SkipIssue123.java[tags=extractWorkflowId]
----

In this example, we identify the page with all parameters in query string in addition to the servlet path.

==== Complete sample

You have the sample https://github.com/wuic/wuic-samples/tree/wuic-0.5.x-snapshot/js-css-sample[here].

++++
<table>
    <tr>
        <td>Parameter name</td>
        <td>Description</td>
        <td>Default value</td>
    </tr>
    <tr>
        <td>c.g.wuic.filter.disableServerPush</td>
        <td>Never use HTTP/2 server-push even if possible and use server-hints instead</td>
        <td>false</td>
    </tr>
    <tr>
        <td>c.g.wuic.forceDynamicContent</td>
        <td>Always consider the filtered HTML as dynamic instead of checking if tag support (JSP or Thymeleaf) has been used to generate the response</td>
        <td>false</td>
    </tr>
</table>
++++

== Built-in HTML templating

Built-in templating is a set of features that you can use when your HTML content is optimized by WUIC (using the servlet
`Filter` or by declaring it in a `heap`).

When WUIC optimizes HTML content, it uses by default the `HtmlInspectorEngine` component that supports several tags and
attributes to customize the way your HTML template is optimized.

=== data-wuic-skip: don't optimize the script

If you want WUIC skips files referenced by the HTML file, you can use the `data-wuic-skip` in the tag.
This is useful if you don't want to aggregate a particular resource for some reason. Moreover you can use it
when WUIC does not already supports some features or you find a bug :) (don't forget to file an issue in that case).

Example:

[source,html]
----
<script data-wuic-skip src="script-to-skip.js"></script>
----

=== wuic:html-import: import workflow

Any declared `workflow` can be executed to inject the result in your HTML page just by adding `<wuic:html-import />` tag
with the desired ID associated to the attribute `workflowId`.

Example:

[source,html]
----
<wuic:html-import workflowId="myWorkflow" />
----

== Java Config

=== Purpose

WUIC could be integrated without necessarily use the XML configuration API.
All XML configuration points are directly provided by a `Java` API which could be preferred in several use cases,
especially for frameworks that want integrate WUIC.

*Note:* for deep understanding of `Java` Config purpose, you should take a look at the <<design.html#_configuration_structure,WUIC configuration structure>>.

=== Create the facade

WUIC provides its http://wuic.github.io/apidocs/com/github/wuic/WuicFacade.html[facade] which helps to invoke workflow and configure mainly:

* DAOs (the way you access nuts)
* Heaps (the sets of nuts)
* Engines (the different transformations applied on nuts)
* The chains (the engines called to process the heaps)

You can create a new facade like this:

[source,java]
----
include::{wuic-repository}wuic/core/src/test/java/com/github/wuic/test/ApiTutorial.java[tags=CreateFacadeAPI]
----

We indicate the processed nuts will be served on your HTTP server from `/statics`.
Here all the URLs will be rewritten using this prefix during process (like `background-url` inside CSS).
This means that the result of any process must be reached from this root path (http://localhost/statics for instance).

By default the facade injects DAOs and engines with default settings to make your configuration faster.
This could be disabled with:

[source,java]
----
include::{wuic-repository}wuic/core/src/test/java/com/github/wuic/test/ApiTutorial.java[tags=CreateFacadeNoDefaultAPI]
----

Check the javadoc to see other configurations points exposed by the http://wuic.github.io/apidocs/com/github/wuic/WuicFacadeBuilder.html[WuicFacadeBuilder].

Default instances are created for all DAOs / Engine discovered in the classpath by WUIC.
Additional DAOs and Engine will be available regarding the extensions you add to your classpath.
They are identified by the value specified in their `@Alias` annotation that can be checked in the javadoc below:

* See link:api.html#_configuring_the_nutdao[this page] for DAOs
* See link:api.html#_configuring_the_engines[this page] for engines

The documentation contains also all the default properties.

All components in WUIC are annotated with `@Alias` but this is not mandatory.
If a component is not annotated, the default configuration will be identified by `wuicDefault[SimpleClassName][Builder]`.
For instance `wuicDefaultFoorEngineBuilder` will be the ID for the default instance of `FooEngine` class.

=== Configure the facade

To configure the facade, you can extend http://wuic.github.io/apidocs/index.html?com/github/wuic/ContextBuilderConfigurator.html[ContextBuilderConfigurator]
and implement its two abstract methods:

* http://wuic.github.io/apidocs/com/github/wuic/context/ContextBuilder.html#tag(java.lang.Object)[getTag()]: identifies all the settings you perform in your class. This helps WUIC to keep them when other configurators want to reset their previous operations.
* http://wuic.github.io/apidocs/com/github/wuic/context/ContextBuilderConfigurator.html#internalConfigure(com.github.wuic.ContextBuilder)[internalConfigure(ContextBuilder)]: the http://gdrouet.github.io/wuic/apidocs/index.html?com/github/wuic/ContextBuilder.html[ContextBuilder] used inside the facade where you can define everything you need.

For instance, use can access the `WuicFacadeBuilder` internal `ContextBuilder` and modify it like this:

[source,java]
----
include::{wuic-repository}wuic/core/src/test/java/com/github/wuic/test/ApiTutorial.java[tags=CreateFacadeContextAPI]
----

Alternatively, you can create your own implementation of a `ContextBuilderConfigurator` to configure the `ContextBuilder`:

[source,java]
----
include::{wuic-repository}wuic/core/src/test/java/com/github/wuic/test/ApiTutorial.java[tags=CustomConfiguratorAPI]
----

You can inject an instance in your facade like this:

[source,java]
----
include::{wuic-repository}wuic/core/src/test/java/com/github/wuic/test/ApiTutorial.java[tags=CreateFacadeWithConfiguratorAPI]
----

TIP: you can automatically install any custom `ContextBuilderConfigurator` by relying on
http://docs.oracle.com/javase/7/docs/api/java/util/ServiceLoader.html[ServiceLoader].
This can be achieved by creating a file that contains the class names of different implementations
and called `META-INF/services/com.github.wuic.context.ContextBuilderConfigurator`.

Note that you can also force a facade to be refreshed with a `ContextBuilderConfigurator`:

[source,java]
----
include::{wuic-repository}wuic/core/src/test/java/com/github/wuic/test/ApiTutorial.java[tags=ConfigureAPI]
----

Moreover, you can restrict the execution of any `ContextBuilderConfigurator` if you annotate it with `com.github.wuic.Profile` annotation.

[source,java]
----
include::{wuic-repository}wuic/core/src/test/java/com/github/wuic/test/ctx/ContextBuilderTest.java[tags=CbcProfile]
----

=== Run a workflow

Finally, when your facade has been configured, you can then run any created workflow like this:

[source,java]
----
include::{wuic-repository}wuic/core/src/test/java/com/github/wuic/test/ApiTutorial.java[tags=RunWorkflowAPI]
----

Note that the facade is thread safe so you can use it with concurrency.

++++
<!-- javascript
=================================================== -->
<!-- Placed at the end of the document so the pages load faster -->
<script src="http://code.jquery.com/jquery-1.10.0.min.js"></script>
<script src="bootstrap/js/bootstrap.js"></script>
<script type="text/javascript">
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-40383819-1', 'github.io');
    ga('send', 'pageview');
</script>
++++